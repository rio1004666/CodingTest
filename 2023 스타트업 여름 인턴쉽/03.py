"""
숙제가 n개 주어짐
각 숙제마다 기한이 주어진다 ( 숙제 출제날과 숙제 제출마감날 또 할당시간 )
모든 숙제를 다해야하는데
가능하면 하루에 최대한 적은시간에 숙제를 하고 싶다

관찰 :

하루에 3시간까지만 숙제를 한다고 생각해보자
0일에 A숙제하기 3시간
1일에 A숙제 1시간 B숙제 2시간 투자
2일에 c숙제 3시간을 마무리해야함
3일에 B숙제 마감일이기때문에 3시간 투자 => 근데 2시간투자 못해서 모든 숙제를 다 못함

파라메트릭 서치로 찾는다

그리고 4시간으로 해본다 => 모든 숙제를 다할 수 있음

시간의 하한을 정함

n <= 20만
일수가 364일

어렵다 왜?
하루에 공부해야할 하한 문제
X = 10으로 정해져있다 해도
이시간으로 모든 숙제를 다할 수 있어? 에 대한 질문조차도 어렵다
하나씩 접근하자
처음으로 눈치 챌 수 있는것
하루에 숙제할 수 있는 시간이 짧을수록 곤란.
길수록 널널
내가 사용할 수 잇는 시간이 많을수록 마감이 널널하다

어떤 특징이 있는가
1시간씩 일하면 모든 숙제를 다하기 어려움
10억시간씩 일하면 모든 숙제를 다하기 쉬움
특정시간을 기준으로 짧으면 불가능할거같고
길면 가능할거같다

이런 문제의 특성은 파라메트릭 서치로 구현하기 좋다
단조증가 혹은 단조감소 형태의 배열에서 처음으로
가능하다는 경계에서 가능한쪽이 우리가 원하는 정답이다

매일같이 할 수 있는 선택지가 여러개일 때
예를 들어 A,B,C숙제중 어떤 걸 선택해야하나?
기준은
하나는 내일까지이고 하나는 모레까지인데
오늘 더 빨리 끝나는데 쓰면 다른 숙제들은 남은 기간에 할 기회라도 있는데
더 늦게 끝나는데 쓰면 빨리끝나는데 시간을 투자할 수 없다

빨리 끝나는데 써야 모든 숙제를 하는데에 최선임이 증명된다
하루씩 보면서 내가 남은 숙제를 보면서 가장 빠른기한의 숙제부터 처리하는것이 핵심이다

이 때 우선순위 큐를 사용하면
빨리끝나는 숙제를들 뽑아서 끝낼 수 있다
자료구조 생각
1. 삽입/삭제 가능해야함
2. 가장 빨리 마감되는 숙제를 물어볼때마다 대답할 수 있어야한다
3. 이런 연산을 가능하게 해주는 자료구조는 ? 우선순위 큐


"""
import sys
import heapq
si = sys.stdin.readline
n = int(si())
a = [list(map(int, si().split())) for _ in range(n)]
hw = [[] for _ in range(365)]  # hw[i] := i 일에 시작하는 과제 집합, (끝나는 날, 필요한 시간)
for s, e, h in a:
    hw[s].append((e, h))
def solve(X: int) -> bool:  # 하루에 X 시간 씩 공부해서 모든 과제를 할 수 있는가?
    que = []  # 지금 할 수 있는 숙제들을 들고 있는 우선순위 큐
    for day in range(365):
        for v in hw[day]:  # day 일에 출제된 과제들을 우큐에 추가
            heapq.heappush(que, v)

        cnt = X  # 오늘 내가 사용할 수 있는 시간
        while que and cnt > 0:  # 숙제가 남아있고 && 사용할 수 있는 시간도 남아있음
            e, h = que[0]
            if e < day:  # 이미 기한을 넘은 숙제
                return False

            if h <= cnt:  # 해당 숙제를 다 끝내버릴 수 있다.
                cnt -= h
                heapq.heappop(que)
            else:  # 해당 숙제를 못 끝낸다는 끝
                que[0] = (e, h - cnt)
                cnt = 0
    return not que  # 숙제를 다 끝냈으면 true, 아니면 false
l, r, ans = 0, 1000000000, 1000000000
while l <= r:
    mid = (l + r) // 2
    if solve(mid):
        ans = mid
        r = mid - 1
    else:
        l = mid + 1
print(ans)