"""
나무막대가 n개가 있고 각 나무막대의 길이가 있다
수직선상에 낙서가 m개가 있다 정수 좌표 위에만 존재한다
2번위치에 하나 4번위치에 하나 9번위치에 하나
막대를 놓으면 막대는 자신이 놓여있는 위치의 낙서를 가릴 수 있다 경계선에 있는 낙서도 가려준다
길이가 2인 막대를 2부터 4까지 놓게 된다면 2번에 있는 낙서와 4번에 있는 낙서를 없앨 수 있고 막대끼리 겹쳐서 놓을 수 있다
모든 낙서를 가리고 싶다 필요한 최소개수의 막대를 구라기
1개의 막대만 써서는 모든 낙서를 지울 수 없고 2개를 적어도 써야 모든 막대를 지울 수 있고 정답은 2이다
낙서의 개수 최대 20개까지 가능
막대의 개수는 최대 10개까지 가능
관찰 : 개수가 작으므로 완전탐색으로 생각해볼 수 있다
      그런데 그리디하게 버무려진다

      특이한 부분 : 막대의 개수와 낙서의 개수가 너무 작다
      모든 경우를 탐색하는게 완전탐색이지만 이 문제에 모든 경우를 어떻게 정의할 수 있느냐?
      사용하는 막대의 순서를 하나의 경우로 본다
      막대가 3개가 있다면 1짜리 2짜리 6짜리 왼쪽부터 차례대로 막대를 사용한다면 1->2->6
      1->6->2 / 2->1->6 / 2->6->1 / 6->1->2 / 6->1->2
      내가 사용하는 막대의 길이 순서가 경우로 판단할 수 잇다

      막대를 놓는 모든 순서를 모두 직접 확인해볼 예정이다
      내가 보게 되는 경우의 수가 막대가 n개라면 n! 만큼의 경우의 수를 보게 된다
      어떤 막대를 잘 놓을지 선택할 떄마다
      내가 막대를 1->2->6순서로 놓기로 했다면 이것으로 모든점을 가릴 수 있나? 확인해야한다
      위치 2, 4, 9에 낙서가 있고 1->2->6순서로 막대로 가린다면
      길이 1짜리 막대를 1부터 2까지 놓을수 있고 2부터3까지 놓을 수 있는데 무조건 오른쪽으로 땡겨서 붙이는게 좋다
      그리디하게
      그래서 2부터 3까지 가리는게 좋다
      가려지지 않은 4부터 6까지 길이 2짜리 막대를 사용한다
      아직 모든 낙서를 가려지지 않았기 때문에 6짜리 막대를 9부터 15까지 가리게 된다
      이 순서라면 막대 3개를 다 써야한다
      그런데 막대를 2->1->6순서로 막대를 쓴다면 2부터 4까지 가리고 1짜리 막대로 9번을 가리면 2개를 쓰므로
      앞전의 1->2->6 막대순서를 사용해서 3개 모두를 써야하는 것보다 적게 쓰므로 정답을 업데이트 한다

"""
import sys

si = sys.stdin.readline
n, m = map(int, si().split())
dots = sorted(list(map(int, si().split())))
lengths = list(map(int, si().split()))
ans = m + 1
used = [False for _ in range(m)]


def func(idx, cnt):  # idx 번째 점을 덮을 차례
    global ans
    if idx == n:
        ans = min(ans, cnt)
        return

    for i in range(m):  # i 번 길이를 갖는 구간을 사용 시도하기
        if used[i]: continue  # 이미 사용한 길이라면 무시하기
        used[i] = True
        nxt, end = idx, dots[idx] + lengths[i]  # dots[idx] 부터 dot[idx] + lengths[i] 까지 구간을 덮는다면 어느 점까지 덮어지는 지 찾기
        while nxt < n and dots[nxt] <= end:
            nxt += 1
        func(nxt, cnt + 1)  # 이제 nxt 점을 덮을 차례이므로 재귀 호출
        used[i] = False


func(0, 0)
if ans == m + 1:
    ans = -1
