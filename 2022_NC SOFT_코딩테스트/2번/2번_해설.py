# A^B에서 일의자리수부터 5자리수까지 수를 구하기
# ex) 1234556  이 A^B의 결과라면 34556 이 5자리수이다
# A 와 B 둘다 제한 10억

import sys
si = sys.stdin.readline
a, b = map(int, si().split())
mod = 100000
a %= mod
def solve1(a, b):  # 분할정복을 이용한 거듭제곱, O(log B) => 검색하면 쉽게 나옴
    if b == 0:
        return 1
    v = solve1(a, b // 2)
    v = (v * v) % mod
    if b % 2 == 1:
        v = (v * a) % mod
    return v

# 여기서 그래프로 해결할 수 있다
# 수학문제이지만 관철로 사이클이 존재하는것이 보이고 규칙이라는것이다
# 2의 제곱승부터 찬찬히 보면 2의 제곱은 4 그다음 8...그리고 다시 끝 두자리가
# 04로 오면서 이것은 4와 같으므로 20제곱을 하면 다시 처음으로 돌아온다는것을 알 수 있다
# 효율성 문제에서 중요한 개념이다 => 수학적 사고 방식 + 규칙성 찾아내기
# 또한 그래프문제라고 볼 수 있는것은 2에서 4로 x2를 해서 상태변화가 되므로
# 이 곱하는 과정이 간선으로 될 수 있다
# 1에서 시작해서 화살표를 이용해서 (간선을 타고)
# 100번 이동하는것과 같다
# 싸이클을 미리 안다면
# 100억번도 이 싸이클의 길이를 이용하면 빠르게 계산할 수 있다
# 싸이클의 길이가 위의 2의 제곱승을 하다가 2자리수가 같아지는 순간이 20제곱을
# 했을 경우이다
# 그래서 결론은
# 1. 싸이클을 찾는다
# 싸이클 아닌 구간에서 찾을 수 있다 싸이클 진입하기 전까지 구간은
# 정점은 숫자이고 간선은 그 숫자에서 곱해서 어느 숫자로 가느냐이다
# 2. A^B을 계산
# 다행히 이 문제에서는 끝 5자리라는 키워드가 핵심이고
# 숫자범위는 0 ~ 99,999 이고 최대 십만번이다 결국 십만번 후 사이클이 돌수밖에없다
# 그래서 이 10만번으로 정해진 이 싸이클 길이을 찾기만하면 쉽게 구할 수 있다
# 그래서 시간복잡도는 10만이 된다
# 핵심은 수학문제라고 생각했지만 - 분할정복알고리즘으로 풀기
# 그래프 문제로 풀기 - 상태의 변화 정점과 간선으로 이루어짐  ( 끝 5자리면 숫자는 10만까지 존재 )
# 핵심 2 . 10억이라는 키워드, 끝 5자리수 => 이를 통해 사이클이 존재한다라는것을 파악
# 그래프문제는 정점과 간선으로 이루어져있고 반드시 어떤 물리적인 정점과 노드로 존재하지는 않는다 => 상태의 변화가 될 수 있다 즉 논리적인 연결들로 정점과 간선으로 이어질 수 있기때문에
# 내가 어떻게 해석하냐에 따라서 그래프 문제가 될 수 있다는 것
# 그리고 여기서 그래프 문제라고 해서 단순히 dfs bfs 알고리즘도 아니며
# 또 인접리스트로 표현되는것이 아니다 첫 루트 노드에서 간선을 타고 이동할시에는 인접행렬로 표현하기도 하며 반복문을 이용하기도 한다
# 예를 들어 끝 두자리로 표현하게 되면 범위는 0 ~ 99 까지일거고 -> 100번째는 같아지는 싸이클구조이다
# 싸이클 부분 인덱스는 헷갈릴 가능성이 있으므로 적어보면서 체크한다
def solve2(a, b):  # 그래프를 이용한 거듭제곱, O(10만)
    arr = []
    idx = [-1 for _ in range(100001)]  # idx[num] := num 이라는 수가 arr의 몇 번지에 등장했었나
    idx[a] = 0
    arr.append(a)
    v = a
    while True:
        v = (v * a) % mod
        if idx[v] != -1:  # 싸이클을 찾은 순간
            cycle_length = len(arr) - idx[v]
            cycle_start = idx[v]
            break
        idx[v] = len(arr) # 각 숫자의 번지를 계속 기록하면 언젠가 -1이 아닌 인덱스를 찾게 되면 싸이클이 형성됨을 알 수 있다
        arr.append(v) # 다음 숫자(정점)을 추가함
    # 싸이클 내로 그래프 탐색이 진행된다면 바로 리턴한다 그 숫자를
    if len(arr) >= b:
        return arr[b - 1]

    # 싸이클 한바퀴돌고 더 진행해야 한다면 싸이클 돈 후 몇번재인지 인덱스 조작을 수행한다

    # 싸이클 총 길이는 19이고 그래프 탐색 인덱스가 20번째라면 arr[1]을 반환해야하므로 20 - 1 - 1

    for i in range(cycle_start, len(arr)):

        if (b - 1 - i) % cycle_length == 0:

            return arr[i]

print(solve1(a, b), solve2(a, b))