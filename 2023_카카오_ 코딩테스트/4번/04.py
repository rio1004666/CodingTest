"""

1. 문제이해

   이진트리를 수로 표현하기

   1) 이진수를 저장할 빈문자열 생성
   2) 주어진 이진트리에 더미노드 추가 => "포화" 이진트리로 만듬 => 루트노드 그대로 유지
   3) 왼쪽부터 오른쪽으로 살펴보면서 더미노드라면 0을 추가하고 아니라면 1을 추가
   4) 문자열에 저장된 이진수를 "십진수"로 변환

   수가 주어지네 7이 주어지면

   7 = 4+2+1
   7(2) = 111
   63(2) = 0111111
   111(2) = 1101111

2. 관찰
   10진수가 주어진다...2진수로 바꾼다 (문자열로)
   그런데 포화이진트리가 되어야하므로 0을 패딩해야하는데 홀수개로 맞춰야겟지
   예를 들어 7은 2진수로 바꾸면 홀수개이므로 포화이진트리이고 더미노드인 0을 패딩할 필요가 없어
   가장 중간에 있는 루트노드부터 시작해서 탐색한다
   그런데 예제와 같이 5와 95는 이진트리로 표현할 수 없다 왜? 루트노드가 0이므로 (패딩X)
   각 서브트리의 루드노드는 1이 되어야만 한다 즉 각 서브트리의 중간노드는 1이어야한다 -> 0이면 탈락
   10진수 -> 이진수문자열 -> 분할 정복과 비슷한 재귀 탐색 -> 중간노드 확인 -> 1이면 계속탐색 -> 0이면    False 판정 후 진행 X
   리프노드에 아무것도 없다면 즉 0이라면 (더미노드 패딩) True반환

   더미패딩 작업은 만약 짝수개라면 홒수개로 맞춰야하기 떄문에
   왼쪽 오른쪽 끝을 보며 루트노드가 있는 즉 1이라면 붙이고 아니면 안붙인다

   주의해야할 사항

   0을 패딩할 경우 포화이진트리 개수에 맞게 해주어야하므로 원래 이진수로 표현하였을 경우의 개수와 비교해서 포화이진트리의 개수에 맞추어 0을 패딩해야함 예를들어 이진수 자리수가 12개이면 포화이진트리가 되기 위해 15개가 되어야하므로 '0' 3개를 패딩함

   또 0을 세개 패딩하였을 경우에는 포화이진트리가 성립됨 (더미노드)
   100 , 001, 101 인 경우에 루트노드가 없는데도 자식노드가 있기때문에 포화이진트리 성립안됨

3. 시간복잡도 계산
   10,000개의 쿼리 x 이진수 재귀 분할 탐색 Loglen(S) = 시간 충분

4. 구현

"""


def graph_search(binary: str, L: int, R: int) -> bool:
    if L == R:
        return True
    # 루트노드의 위치
    mid = (L + R) // 2
    # 루트노드
    root = binary[mid]
    # 왼쪽 서브트리의 루트노드

    left_child = binary[(L + mid - 1) // 2]
    right_child = binary[(mid + 1 + R) // 2]
    if left_child == '1' and root == '0':
        return False
    if right_child == '1' and root == '0':
        return False

    # 나는 그냥 루트노드가 0이면 포화이진트리 성립요건이 안된다고 보았다 (이진트리도 성립안됨)
    # 루트노드가 그냥 0이라서 거짓판정을 내리게 되면 정답이 틀린다
    # 만약 루트노드가 0이고 자식노드들이 0이라면 더미노드로 패딩해서 포화이진트리로도 만들 수 있기 떄문이다
    # 0111000 -> 이것도 포화이진트리다 가장 뒤에 있는 세개의 0은 포화이진트리로 성립된다 (루트노드가 0이지만 자식들도 0이기에 성립한다 그런데 루트노드가 0인데 자식노드가 1이라면 성립이 안됨 )
    result = graph_search(binary, L, mid - 1) and graph_search(binary, mid + 1, R)

    return result


def solution(numbers):
    answer = []
    # 각 숫자를 2진수로 표현하는 문자열 출력 ( 테스트 )
    for number in numbers:

        binary = bin(number)[2:]

        # 더미노드를 패딩해야 한다 포화이진트리는 개수가 정해져 있다 1,3,7,15.........
        # 반복문으로 tree size를 측정한다

        # 내가 생각하지 못했던것은 이진수로 표현했을 때 12개인경우 포화이진트리로 만들기 위해 세번의 0을 패딩해야하는데 하나만
        # 패딩하니까 문제가 된다 이러한 케이스를 생각해야 한다 1개만 패딩한다는 단순한 생각을 하면 안된다
        # 예를 틀어 이진수로 표현했을 떄 13자리인 경우는 2개를 붙여야하고 10개인 경우 5개를 붙여야 포화이진트리가 된다는점

        tree_size = 1

        while tree_size < len(binary):
            tree_size = (tree_size * 2) + 1
        binary = '0' * (tree_size - len(binary)) + binary
        # 이제 tree size만큼 패딩한다

        # print(binary)
        print(len(bin(1000000000000000)))
        if graph_search(binary, 0, len(binary) - 1):  # 수가 포화이진트리로 표현할 수 있다면 1을 출력한다
            answer.append(1)
        else:  # 수가 포화이진트리로 표현할 수 없다면 0을 출력한다
            answer.append(0)
    return answer