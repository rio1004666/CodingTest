


def solution(edges,target):

    answer = []
    n = len(target) # 총 노드의 갯수
    tree = [[] for _ in range(n)]
    # 인접리스트로 그래프 형성
    for par,child in edges:
        par -= 1
        child -= 1
        tree[par].append(child)
    # 각 부모노드가 가리키고 있는 자식노드 번호를 저장할 리스트
    road = [0 for _ in range(n)]
    # 순서대로 도착하는 노드를 기억하는 리스트
    arrive = []
    # 계속 구슬을 떨어뜨리면서 만족할때까지 몇번 방문했는지 각노드마다 몇번씩 방문했는지 카운팅하는 리스트
    arrive_count = [0 for _ in range(n)]
    # 점수가 필요한 노드들의 갯수를 카운팅한다
    leaf_nodes = 0
    for t in target:
        # 점수가 필요한 리프 노드들의 갯수를 카운팅한다
        if t > 0:
            leaf_nodes += 1
    # 점수가 필요한 노드들이 없어질때까지 구슬을 떨어뜨리며 리프노트들을 바뀐 경로대로 차례로 방문한다
    # 경로가 계속 바뀌므로 방문할 노드들의 순서들을 기록해놓으면 나중에 편리하게 방문노드에 구슬들만 1,2,3을 떨어뜨려보면된다
    while leaf_nodes:
        x = 0  # root 노드부터 시작한다
        # 현재 루트노드에서 자식노드까지 가는데 리프노트는 자식노드가 없기에 비어있다 그래서 빌때까지 반복하다보면 언젠가 리프노드에 도착한다
        # 그래프의 탐색은 이렇게 반복문으로 가능하다
        while tree[x]:
            next_x = tree[x][road[x]] # 현재노드에서 가리키는 하위노드로 이동하고
            road[x] = (road[x] + 1)  % len(tree[x]) # 현재 노드에서 그다음 큰노드번호를 선택하는 작업 => 문제에서 마지막 노드에서 그다음노드는 처음노드로 이동한다고 했으므로 % 연산을 사용하였다
            x = next_x # 다음경로를 다시 현재경로로 설정해주어야한다

        # 해당 노드에 도착하면 도착순서에 차례대로 기록해준다
        arrive.append(x)
        arrive_count[x] += 1 # 몇번 방문횟수도 +1 카운팅 해준다
        # 그다음 이제 리프노드에 다다랐을때 점수가 충족이 되느냐는 최대 3을 보냈을때 충족되는지 체크하면된다
        # 왜냐하면 1이나 2를 보냈을 때는 여러번 방문해야하므로 문제에서 요구하는 최소요건에 부합하지 않는다
        # 3명씩 넣었을때 방문하지 않았을 때 보다 방문했을때 원하는 타겟 스코어가 충족이 된다면 하나씩 필요한 스코어 노드리스트에서 뺀다
        if ( arrive_count[x] - 1 ) * 3 <  target[x] <= arrive_count[x] * 3:
            leaf_nodes -= 1
    ans = []
    for x in arrive:
        cnt = 0
        for a in [1,2,3]:
            visit = arrive_count[x] # 방문횟수
            need = target[x] # 필요한 점수
            last = need - a # 1을 떨어뜨렸을 경우 가능한가?
            # 방문회수는 한정적인데 아직도 필요한 점수가 남아있으면 안되므로
            # 그에 맞추기 위해 범위체크를 해주어야한다
            # 일단 구슬을 떨어뜨리고 마지막 방문하고서 더이상 남는 점수가 없어야한다
            # 최대 방문횟수가 3번남았을때 1씩 떨어뜨릴때 3이쌓이고 3씩 떨어뜨리면 9가 쌓이므로 남은 방문회수동안 1번구슬을 떨어뜨리고 난후 충족할 수 있으면 바로 1을 선택하고 안되면 늘려가면서 방문횧수와 맞추게 된다
            if (visit - 1) * 1 <= last <= ( visit - 1 ) * 3:
                cnt = a
                break
        if cnt == 0:
            print(-1)
            break
        ans.append(cnt)
        target[x] -= a  # a라는 수를 누적했으므로 필요한 점수에서 빼준다
        arrive_count[x] -= 1 # 방문을 한번했으므로 -1 카운팅해준다
    print(*ans)



    # 전처리작업 경로를 계속 변경하면서 모든 노드가 만족할때까지 반복하며 방문하는 순서를 정한다





    return answer