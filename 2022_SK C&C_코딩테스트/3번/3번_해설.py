# 수열이 주어짐 n개
# 이 수열에 마법 사용
# 마법사용 조건
# 똑같은 수를 이어 볼 수 있다
# 원하는만큼 똑같은 숫자를 이을 수 있다 단 구간이 겹치면 안된다
# 구간안에 양끝점과 같은값이 있으면 안된다
# 그 후 마법을 부리면 구간에 포함된 숫자들 중에서
# 제일 왼쪽에 있는 숫자들을 제외하고 사라진다
# 즉 각 구간의 가장 왼쪽숫자만 살아남고 지워진다
# 어떻게 마법을 부려야 남아있는 수를 적게 남게할 수 있을까
# 최대로 구간의 길이를 잡게 한다 => 수와 인덱스만 알면 된다
# N은 100만
# 각 구간의 숫자들 범위는 10억
# 다이나믹 프로그래밍 => 효율성
# 지울수있는구간을 찾는게 1순위이다
# 마법은 딱 한번뿐
# 구간들을 모두 찾는 나이브한 풀이는 시간초과일것
# 어떻게 구간들을 찾을것인가
# 숫자와 인덱스를 같이 저장해서 모아준다
# (수,인덱스) 형태로 자료구조로 한뒤 => 전처리1
# 정렬한다 => 전처리2
# (1,0) (1,4) (1,8) (1,11) ... 이렇게 수들이 뭉쳐잇어서
# 구간들을 찾을 수 있다
# 인덱스의 특성  => 특정구간의 길이를 알 수 있다
# 정렬을 했기에 같은 수에 대해 인덱스가 오름차순으로 정렬되어 있음
# 내가 만들수있는 모든 구간의 길이를 원큐에 해결가능하다
# 구간을 오른쪽끝과 왼쪽끝을 기억하고 있을것이다
# interval[r] := r과 이어지는 왼쪽 구간
# 다이나믹 프로그래밍 테이블 정의
# dp[i] = [0~i]에 대해 마법의 최선 결과 = 남길수있는 원소의 최소 갯수
# dp[i] i가 누군가와 마법을 부리던가 부리지 않던가로 파티션을 나눈다
# 부리지 않는다면 dp[i] = dp[i-1] +  1
# 부린다면 dp[i] = dp[j-1] + 1 # j번부터 i번까지 마법을 부리면 결국 j번째 원소만 살아남으므로 1개만 추가되므로
# 그렇게해서 저 두경우의 중 한가지가 최소가 되는것을 선택
import sys
si = sys.stdin.readline
n = int(si())
a = list(map(int, si().split()))
dp = [i + 1 for i in range(n)] # 초기화는 각 번지에 있을때 원소의 갯수가 저장되어있다
val_idx = [(a[i], i) for i in range(n)]
val_idx.sort()
interval = [-1 for _ in range(n)] # 같은 수가없다면 -1
for i in range(1, n):
    if val_idx[i][0] == val_idx[i - 1][0]:  # 같은 수가 연속으로 등장! 구간 생성 가능!
        interval[val_idx[i][1]] = val_idx[i - 1][1] # 각 위치에서 자신이 구간을 형성할수 있는 구간길이가 나온다
        # 그리고 겹칠수없기때문에 각자 자기 위치에서 바로전에 자신의 수와 같은 수의 구간만 구할 수 있다
        # 4번위치에 있는 수가 1이고 0번위치에 있는 수가 1이면 4번위치에 있는 interval은 0번위치에 있는 수의 위치를 기억할것이다
        # 그러면 길이를 구할 수 있다
for i in range(1, n):
    # i 번째 수를 마법에 사용하지 않음
    dp[i] = dp[i - 1] + 1
    # i 번째 수를 마법에 사용함!
    j = interval[i] # i번째 수와 마법을 부릴 j번지를 가져옴
    if j != -1: # 같은수가 없다면 -1이고 어차피 같은수가없다면 마법을 부릴 수 없으므로 마법을 부리지 않고 그냥 넘어간다
        # j-1번째까지 마법을 어떻게 잘 부린다음에 ( 즉 남아있는 최소 원소의 갯수를 남긴다음에 )
        v = dp[j - 1] + 1 if j >= 1 else 1
        dp[i] = min(dp[i], v)
print(dp[n - 1])

# 이 문제 관철
# N이 비약적으로 높다 100만
# 같은수끼리 구간을 잡는데 겹치면 안된다 구간안에 구간이 있으면 안된다
# 경우의수 => 완전탐색 or 다이나믹 프로그래밍
# 구간의 길이 => 인덱스로 구한다
# 같은수끼리 튜플형식으로 (숫자, 인덱스)를 기억하는것이 여기서 핵심이다
# 그 후에 각 번지에서 앞에 있는 수를 기억해서 구간의 길이를 바로 가져올 수 있게끔하는것이다.
# 정렬
# 그후 다이나믹 테이블 정의를 하고 자식의 번지에서 마법을 부리냐 안부리냐를 판정한다
# 다이나믹 프로그래밍 초기화 dp[i] = 1,2,3,4.... 모든수가 다르면 원소의 갯수는 현재번지+1개만큼 있다






