"""
2 7 9 3 1 4 2 8 3 이라면
최소값 1과 최댓값 9가 엇갈려 있다면 따로 쪼갤수 없으므로 아무것도 쪼갤수 없음 0개
2 7 끊고 9~ 부터 끊으면 전체정렬과 같지 않음 9는 맨뒤로 가지만 1은 맨앞으로 가지 못함
2 7 9 3 1 끊고 4 2 8 3 이라해도 1은 맨앞에 가지만 9는 맨뒤로 가지 못함

2 7 4 1 3 5 9 2 라 하면
2 7 4 1 끊고 3 5 9 2 끊게 되면 1은 맨앞에가고 9가 맨뒤로 가게 되지만 2는 앞에 갈수없음
이렇게 되는 이유는 3이 앞서 끊은 7 4보다 작기때문이다
그래서 끊는 기준은 왼쪽값들과 오른쪽값들로 나누어서 왼쪽에는 큰값들이 존재하고 오른쪽에
작은값들이 존재하는데 까지 반복해서 체크후 쪼갠다
위의 예에서 가장 오른쪽에 2가 있기에 쪼개지 못하고 전체를 정렬해야한다
2가 빠지면
2 7 4 1 3 5 9 라면
왼쪽부분에 7이 있고 가장 오른쪽에 9가 있으므로 9앞까지만 끊으면 된다
그럼 9앞부분은 9보다 작은수들로 정렬이 될것이고 9는 가장 큰수로 그대로 있게 되므로
2개로 쪼개면 가장 많이 쪼내는 갯수로 같아지는 방법이다
그럼 2 4 1 3 7 5 9 라면
2 4 1 3 부분을 보면 3은 4의 왼쪽에 있으므로 무조건 포함시켜야한다 그래서 한 뭉텅이로 보고
2 4 1 3 으로 쪼갠다 그리고 이 수는 나머지 뒤의 수들보다 전부 작으므르ㅗ
2 4 1 3 / 7 5 / 9 로 쪼갤 수 있다
즉 규칙이 왼쪽에 있는 값들이 오른쪽에 있는값들보다 클경우 같은 수열로 묶어주어야한다는것이다
그래서  처음원소가 2 여튼 1보다는 크므로 끊어본다 그리고 4도 2보다는 크므로 끊어본다
1이 나오면 앞의 2 4 보다 작으므로 포함시켜서 끊어야한다 2 4 1 끊는다
3도 4보다는 작으므로 포함시켜서 끊어야한다 최댓값을 갱신하면서 끊으면 된다
최댓값이 2 4 4 4 이므로 최댓값보다 크면 바로 쪼개고 작으면 포함시켜서 쪼갠다  최솟값도 기록한다
최솟값보다 크고 최댓값보다 작은경우 그렇게 포함시켜서 한번 쪼갠다

위의 경우를 다시보자 2 4 까지 나오고 1이 나온다면 최솟값보다 낮으므로 포함시켜서 쪼개야한다
3이 나오면 최댓값보다 낮으므로 포함시켜서 쪼개야한다 7은 최댓값이상이므로 독단으로 쪼개도 된다
5는 최댓값보다 낮으므로 포함시켜서 쪼개야한다
9는 최댓갑보다 크므로 독단으로 쪼갠다
만약 뒤에 2가 나오면 최댓값보다 작으므로 포함시켜서 쪼개야한다 즉 전체를 한 수열로 봐야하고 1개로 ㅗ개는것이다

"""

# 포인트
# 각 원소가 정렬했다고 치면 어디로 가야하는 지를 찾는다.
# 그러면 문제가 원하는 대로 구간을 나누려면, 다음과 같은 조건을 만족해야 한다.
# [i ... j] 가 새로운 그룹이 되려면, max(target_index(k), i <= k <= j) = j
import sys
si = sys.stdin.readline
n = int(si())
a = list(map(int, si().split()))
ord = [(a[i], i) for i in range(n)]
ord.sort()
tgt_idx = [0 for _ in range(n)]  # tgt_idx[i] := 원래 배열에서 i 번 원소가 정렬하면 tgt_idx[i] 번으로 가야 한다.
for i in range(n):
    tgt_idx[ord[i][1]] = i
ans, mx = 0, 0
for i in range(n):
    mx = max(mx, tgt_idx[i])
    if mx == i:  # 연속한 구간에서의 최댓값이 현재 원소의 번호랑 같으면, 여기서 새로운 구간을 짜를 수 있다.
        ans += 1
print(ans)