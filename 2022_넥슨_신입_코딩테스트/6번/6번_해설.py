"""
a수열이 주어졌을 때 b,c수열로 쪼갬
쪼개는 규칙은
b는 오름차순
c는 내림차순 정렬
각 b,c 원소의 합이 a배열 원소와 같아야한다
b,c수열로 나눌 수 있는 경우의 수 - 방법 - 다이나믹 프로그래밍가능성
n = 3000 제한
경우의수는 겁나 많을수잇고 아예없을 수 있다

접근 - 다이나믹 테이블 두개를 만든다
dp(i,v) i번째까지 b,c로 잘 쪼갤 수 있고 b의 v번째를 선택했을 경우의수
dp2(i,v) b수열의 마지막이 v이하의 경우의수 - dp 배열 점화식에 필요해서 미리 계산
dp초깃값 => dp[0][0] ~ dp[0][a[0]] = 1 ( a의 첫번째 원소가 3이면 b의 v번째원소가 0일수도 있고 1일수도 있고 2일수도 있고 3일수도 있기에 각각 1가지 경우의수이다 )
dp2초깃값 => dp2[0][0] = 1 dp2[0][1] = 2 dp2[0][2] = 3 dp2[0][3] = 4 ... dp2[0][3000] 까지 4로 저장해준다
이유는 현재 선택된 v의 값이 4라면 c의값을 -1이 되고 음수가 되기에 방법이 될 수 없음 ( 양수로 문제에 명시 ) 그래서 당연히
dp[0][3] = 4 지만 dp[0][4] = 0 이 된다
dp2[0][4] = 4가 되고 계속 0이므로 더해도 4가된다

점화식
dp[i][v] = i번째까지 어떻게 잘 쪼개서 v를 선택하면 좋다
b 배열 v 번째 수 선택하면
c 배열 a[i] - v 로 되고
b배열은 0 <= b[i-1] <= v 가 된다 (음수 안됨)
c배열은 0 <= b[i-1] <= a[i-1] - a[i] + v 가 된다 (음수 안됨) 이항 시키기전  a[i-1] - b[i-1] >= a[i] - v
위의 두조건을 동시에 만족하면 된다
dp[i][v] = dp[i-1][0] + ~ + dp[i-1][u]
u는 위의 b[i-1] 조건 범위 내에서 최대값이 더 작은값을 선택 ( 교집합 )
dp2[i-1][u] 에 이미 있기때문에 상수시간에 구할 수 있다
시간복잡도는 dp의 공간크기만큼 시간복잡도를 가진다 O(N3000)이 된다

이 문제의 포인트 b,c로 쪼개면서 하나씩 원소를 보면서 조건을 정한다 ( 오름차순 내림차순 )

"""

import sys
si = sys.stdin.readline
MOD = 1000000007
n = int(si())
a = list(map(int, si().split()))
dp = [[0 for _ in range(3001)] for _ in range(n)]
dp2 = [[0 for _ in range(3001)] for _ in range(n)]
for i in range(n):
    if i == 0:
        for v in range(a[i] + 1):
            dp[i][v] = 1
            dp2[i][v] = v + 1
    else:
        for v in range(a[i] + 1):
            # b 가 오름차순 이어야 하는 조건
            # b[i] = v
            # b[i-1] <= b[i] = v
            # c 가 내림차순 이어야 하는 조건
            # c[i] = a[i] - v
            # c[i-1] >= c[i] = a[i] - v
            # a[i - 1] - b[i - 1] >= a[i] - v
            # b[i-1] <= a[i-1] - a[i] + v
            upper = min(v, a[i - 1] - a[i] + v)  # b[i - 1] 이 가질 수 있는 최댓값
            if upper >= 0:
                dp[i][v] = dp2[i - 1][upper]

            dp2[i][v] = dp[i][v]
            if v > 0:
                dp2[i][v] += dp2[i][v - 1]
            dp2[i][v] %= MOD
    for v in range(a[i] + 1, 3001):
        dp2[i][v] = dp2[i][v - 1]
print(dp2[n - 1][3000])