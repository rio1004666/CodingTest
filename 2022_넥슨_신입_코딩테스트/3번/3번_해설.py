"""
26개의 종족이 있다 a-z종족이 있는데
같은 종족끼리 모이면 시너지 낸다
똑같은 사람이 세명이 모이면 p^3
4명이 모이면 p^4
5명이 모이면 p^5이 된다
n -> 6 / k = 3이면
daabcb 이고 이중 3명을 골라서 파티를 꾸리면
연속적으로 고른다
각 선택지마다 총 에너지를 계산할 수 있다
만약 d*1 = 4 와 a*2 = 1^2 로 다 더해져서 16이 된다 (알파벳순서로 1,2,3,4점)
n명이 일렬로 서있을때 k명을 골라서 계산한 에너지점수중에서 가장 클때의 점수를 구하기
10^9 + 7로 나눈 나머지
n과 k는 10만까지 가능하다

문제이해
관철 (올바른 방향 ) + 일단 나이브하게 풀이생각 - 정답을 구할 수 있겠지만
O(NK)라는 시간이 걸린다 - 완탐을 할수는 없다
k명 고를때마다 a가 몇명인지 b가 몇명인지 다 계산후 더해주는 작업을 하면
그래서 효율적인 측면을 생각해야한다
정해는 어떻게 푸냐 - 연속하다라는 것이 중요한 키워드이다
누적합!!!! 알고리즘
연속해있기때문에 다음으로 속한 파티는 잘하면 이전의 한칸 왼쪽에서 구했던 총에너지 x'을 쉽게 구할수있다!
window 로 한칸씩 밀면서 총에너리르 구함 윈도우가 미끄러진다라는것을 슬라이딩 윈도우 라는 알고리즘이 있다
내가 필요한 값을 일일이 구하지말고 이전의 값을 잘 이용해서 구한다
처음에는 k명만큼의 점수를 구하고 각 알파벳에 해당하는 점수를 더하고 빼고 계산한다
aaabbcc 이면 처음 6명은 aaabbc 이고 a를 빼고 c를 더하게 된다 다음 슬라이딩 윈도우때는
첫 6명은 aaabbc이므로 a3명 b2명 c1명 이렇게 되고
총에너지 x = 1^3 = 2^2 + 3^1 = 8이되고
다음 윈도우는 aabbcc이고 1명이 윈도우에서 빠지고 한명이 윈도우에 추가되는 과정이므로
k-1명은 이전의 x에서 변화량을 계산할것이다 a가 빠짐으로써 생기는 변화량과
c가 더해지면서 추가되는 변화량 - 그런데 모이면
# 그러면 기존에 값을 빼고 다시 추가한 변화량의 점수계산을 더해주면된다 ( 추가가 됫을 경우 )
# 이제 누가 빠짐으로 인해서 변화하는 에너지량은 어떨까?
# 삭제 % 기존 cnt명
x <- %^cnt
x' <- %^cnt-1
# 그런데 %^0 은 0으로 고려 ( 0명 )

그래서 결론은 -3^1 + 3^2 이되고
-1^3+1^2이 된다
그런데 고려해야할부분은 5^1000도 느리기때문에 미리 계산해놓아야한다
종족마다 몇명이 있는지를 기록할 새로운 자료구조 배열로 관리해야한다 - 추가되면서 기존에
그리고 제곱을 계산하는것도 상당히 오래걸리기때문에 배열로 관리한다.
이 두가지의 자료구조로 모두 복잡도 1로 계산가능하다


알고리즘 자료구조 분석 - 슬라이딩 윈도우 ( 효율성 )+ 자료구조 배열 기록 ( 효율성 )
구현

키워드 뽑기 26개 종족
연속된 k개 뽑기

"""
import sys
si = sys.stdin.readline
MOD = 1000000007
n, K = map(int, si().split())
a = list(map(lambda x: ord(x) - ord('a') + 1, si().strip())) # 알파벳을 숫자로 바꾸어주는 람다함수 작업
# 모든 필요한 제곱수를 미리 계산하는 작업 - 효율성
powers = [[0 for _ in range(n + 1)] for _ in range(27)]  # powers[i][k] := (i ^ k) % MOD
for i in range(1, 27):
    powers[i][0] = 1
    for k in range(1, n + 1):
        powers[i][k] = (powers[i][k - 1] * i) % MOD
    powers[i][0] = 0  # 쉬운 구현을 위해 0 명인 경우에 i^0 을 1 대신 0 으로 저장한다.
ans, sum = 0, 0
cnt = [0 for _ in range(27)]  # cnt[i] := (i가 등장한 횟수, power(i, (i가 등장한 횟수)))
# 슬라이딩 윈도우 되면서 새롭게 추가되는 종족
def push(num):
    global sum
    sum -= powers[num][cnt[num]]  # num ^ cnt[num]  만큼을 점수에서 제거
    cnt[num] += 1                 # cnt[num] 을 하나 증가
    sum += powers[num][cnt[num]]  # 새로 계산한 num ^ cnt[num] 을 점수에 추가
    sum %= MOD
# 슬라이딩 윈도우되면서 빠지는 종족
def pop(num):
    global sum
    sum -= powers[num][cnt[num]]  # num ^ cnt[num]  만큼을 점수에서 제거
    cnt[num] -= 1                 # cnt[num] 을 하나 감소
    sum += powers[num][cnt[num]]  # 새로 계산한 num ^ cnt[num] 을 점수에 추가
    sum %= MOD
for i in range(n):
    # i 번째 원소를 파티에 추가
    push(a[i])
    # k명을 만족하는순간부터 빠지게 된다
    if i >= K:  # i - k 번 사람이 이제 파티에서 빠질 상황
        pop(a[i - K])
    # 정답 업데이트
    if i >= K - 1:
        ans = max(ans, (sum + MOD) % MOD)
print(ans)