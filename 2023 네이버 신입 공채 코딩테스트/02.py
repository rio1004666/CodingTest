"""
1. 문제이해
N 과 K 가 주어질 때
N 이라는 숫자를 들고 쪼갤 수 있다
각 순간마다 숫자를 골라서 3가지 작업을 할 수 있다

1번 작업 : 내가 고른 숫자(X)가 K초과라면 X -> [X,X-K]로 쪼갤 수 있다
2번 작업 : 내가 고른 숫자(X)가 짝수라면  X -> [X/2,X/2]로 쪼갤 수 있다
3번 작업 : 내가 고른 숫자(X)가 홀수라면  X -> [(X-K)/2,(X-K)/2]로 쪼갤 수 있다

더이상 자를 수 없을때까지 쪼갤 때 가능한 경우의 수를 구하시오

N = 10 , K = 3

10 -> [10/2,10/2] -> 5하나 고른다 -> [5,5-3] -> 2를 고른다 -> [2/2,2/2] .....

처음부터 끝까지 작업을 진행했을 경우 가능한 방법의 수를 구하시오

선택할 수 있는 수가 여러개라면 가장 작은수부터 고르면 됩니다

N <= 20만
K < N , K는 홀수

정답을 10억7로 나눈 경우의 수

2.관찰 : 보자마자 떠오르는 방법

항상 가장 작은 숫자만 나눌 수 있기 때문에 중복은 가능하지 않다

제한시간 : 1초

힌트 : n은 20만 이하 / 10억7로 나눈 나머지가 정답 -> DP 혹은 수학

완탐은 불가 -> DP로 접근 => 최적부분 문제 해결 구조 => 작은문제를 활용하여 큰문제를 푼다 => 공간/시간 복잡도 감소

DP 직관적으로

모든 경우를 손으로 그려보아도 엄청난 경우의 수가 된다

20만까지 간다고 하면 말이안된다

DP의 기본적인 관찰 : 나한테 중요한 상태가 뭘까?

dy[....] 에 대한 고민

실제 매순간 어떤 숫자들이 있는지 봐야하는가?
그럴 필요 없이 특정 숫자에 대한 정의만 있으면 된다

3..DP 테이블 정의
  dy[X] : X라는 수를 분해 경우의 수

7을 [3,4] 로 쪼개서 시작하는 것들끼리 모이게 하고
   [2,5] 로 쪼개서 시작하는 것들끼리 모이게 하는 경우의 수로 나눈다
   [3,4]로 쪼개서 시작하는것들의 경우의 수 2가지와
   [2,5]로 쪼개서 시작하는것들의 경우의 수 3가지를 합친다

   2와 5로 나누어지는 순간부터 별개의 이야기가 된다

   N을 X,Y로 쪼개는 전개를 한다면 X와 Y로 쪼개는 경우의 수는 독립시행이므로

   경우의 수는 곱하면 된다 ( 경우의 수 독립시행 => P(A) X P(B) = P(X)

   dy[N] = dy[X] x dy[Y]

   이렇게 관찰을 했다면

4. 점화식을 구한다
   짝수면 두 가지의 경우가 있는데
   A = dy[N/2] x dy[N/2] 로 정의할 수 있다
   B = dy[K] x dy[N-K] 로 정의하고

   그런데 생각해보아야할 테스트 케이스는 중첩되는 경우이다
   N = 10 , K = 5인 경우
   위의 두가지 경우 A = B 가 된다
   그래서 동치인 경우 A한가지만 간주하고 그 외에는 A+B가 된다



   홀수인경우

   N -> A = [(N-K)/2,(N-K)/2]
        B = [K,N-K]

   홀수인 경우는 A,B가 겹치지 않기 때문에 그대로 A+B이다

5. 구현
   1) 필요한 자료구조
   2) 필요한 알고리즘
"""

import sys

si = sys.stdin.readline
MOD = 1000000007
n, k = map(int, si().split())
dy = [0 for _ in range(n + 1)]
for i in range(1, k + 1):  # k 이하에 대해 문제를 먼저 풀자
    # k, n-k 로 나누는 경우가 불가능한 상황들
    if i % 2 == 0:
        dy[i] = (dy[i // 2] * dy[i // 2]) % MOD
    else:
        dy[i] = 1
for i in range(k + 1, n + 1):  # k 초과에 대해 문제를 풀자
    if i % 2 == 0:
        A = (dy[i // 2] * dy[i // 2]) % MOD
        B = (dy[k] * dy[i - k]) % MOD
        if i == k * 2:  # i 가 k의 정확히 2배라면, 두 케이스가 동치여서 중복을 피해야 함
            dy[i] = A
        else:
            dy[i] = (A + B) % MOD
    else:
        A = (dy[(i - k) // 2] * dy[(i + k) // 2]) % MOD
        B = (dy[k] * dy[i - k]) % MOD

        dy[i] = (A + B) % MOD
print(dy[n])
"""
마지막 팁
파이썬인 경우 오버플로우가 없기 때문에 계산하는 과정에서 답은 제대로 나오지만 수가 길어질수록 계산속도가 느려지기 때문에 터진다 
그래서 중간중간에 MOD 로 나누어주어야 빠르게 계산할 수 있다 
계산을 할때마다 나누면 틀릴수도 있다.....
마지막에 한번만 나누면 되지 않을까???

"""










