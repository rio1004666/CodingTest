"""
1. 문제이해

수직선 두개가 있다 1부터 1000번 집

윗쪽 동네 A : 1번집부터 1000번집까지 있다(N명)
N명의 사람들이 여러집 위치에 뿌려져있다
정보는 자신의 고유번호 ID와 특성을 가지고 있다

아랫쪽 동네 B : 1번집부터 1000번집까지 있다(M명)

동네 B도 동일하다

그런데 A동네와 B동네가 선을 본다
특성이 E인사람은 반대편 동네에서 가장 먼위치에 살고 있는 사람을 고릅니다
특성이 I인사람은 반대편 동네에서 가장 가까운위치에 살고 있는 사람을 고릅니다
만약에 가장 가까운 위치가 여러군데라면 가장 낮은 번호를 가진 사람을 선택
운좋게도 서로가 생각하기에 가장 좋은 파트너로 선택했다면 결혼하고 나갑니다
매라운드마다 선택하면서 매칭이 된사람이 나가고 더이상 매칭되지 않을 때까지 반복할 떄
최대 매칭 커플 수를 구하라

2. 관찰

   우선 브루트포스방식으로 한라운드를 진행해본다 => 되겠지?????
   1000집과 1000집이라고 가정(최대 N ,M)
   매라운드마다 O(2NM) 로 선택할 사람을 찾아야한다
   그리고 최악의 경우로 1000번 매칭해야한다면 (라운드 1000번) 20억번의 시간초과 난다
   물론 커플이 탄생할 떄마다 사람이 나가서 저것보다 현저히 낮은 시간에 진행되겠지만
   그러면 라운드수는 줄일 수 없고
   한동네 사람이 반대편 동네 사람 모두 검색하는 시간을 O(1000*N)으로 해결할 수 있다.

3. 시간복잡도 해결방법 생각하기

   E/I 를 각각 따로 생각하기
   1.E성향을 가지고 있는 사람인 경우
   A동네에서 E는 1번집에 가장 가까운 사람과 1000번집에 가까운사람을 보면된다 왜?
   자기가 있는 위치에서 가장 거리가 먼곳만 보면 되니까, 즉 가운데에 끼여있는 집들은 볼 필요가 없다(브랜칭 사고)
   E성향의 사람이 700위치에 있다면
   100 300 600 900 980 모두 볼 필요가 있을까? NO! 이다
   1번과 가까운 100번 집과 1000번과 가까운 980번만 본다 이 둘 중 가장 먼곳은 100번집만 보면 된다

   2.I성향을 가지고 있는 사람인 경우
   현재 자신의 위치에서 왼쪽에서 가장 가까운 사람과 오른쪽으로 가장 가까운 사람 둘만 알면 된다
   이 두집외에는 볼 필요가 없다 어차피 가장 가까운사람만 볼것이기 떄문에

   투포인터로 접근할경우 같은집에 여러명이 살고 있다면 문제가 되고 가장 낮은 아이디를 구해야하는 이슈가 있다....

   그래서 내가 필요한 사람을 정리하자면
   1. 외향적(E) 사람이 원하는 사람 ( 위치 : u )
      1) 1번 이상에서 1과 가장 가까운 사람을 찾는 행위
      2) 1000번 이하에서 1000과 가장 가까운 사람을 찾는 행위
   2. 내향적(I) 사람이 원하는 사람 ( 위치 : v )
      1) v에서 왼쪽방향으로 가장 가까운 사람을 찾는 행위
      2) v에서 오른쪽방향으로 가장 가까운 사람을 찾는 행위

   위의 문제에 대해서 대답을 빨리 할 수 있으면 되자나? => 검색의 속도를 빠르게 하기 위한 셋팅 스킬
   모든 v에 대해서(1~1000) 질문을 미리 풀어 놓는다
   미리 기록해놓고 배열의 인덱스로  접근하면 복잡도 1로 마치 순간이동처럼 마법이 된다

   left[v] : v의 왼쪽(이하)에서 v와 가장 가까운 사람
   right[v] : v의 오른쪽(이상)에서 v와 가장 가까운 사람

   left 배열에는

   100번집 200번집 400번집 900번집 이렇게 수직선상에 있다면
   100번이하의 집들에 대해서는 왼쪽에 집이 없으므로 -1을 넣어준다
   100이상 200번이하의 집들에 대해서는 가장 가까운집이 100번이므로 모두 100을 넣어준다
   200이상 400이하의 집들에 대해서는 200번이 가장 가까우므로 200을 넣어준다
   ....

   right 배열에는

   100번이상 200번이하 집을 기준으로 200이 가장 가까운 집이므로 200번을 넣는다
   200번이상 400번이하 집을 기준으로 400이 가장 가까운 집이므로 400번을 넣는다
   ....

   이렇게 배열만 넣어놓으면 어떻게 활용할 수 있는지 확인한다
   A동네에서 v라는 위치에 E성향(외향적) 사람이 산다고 가정하자
   이 사람은 어디를 보면되냐면
   B동네에서 1번에서 가장 가까운사람과 1000에서 가장 가까운 사람을 찾으면 되는건데
   1이랑 가장 가까운 집은 right[1]에 써져 있을 것이다
   1000이랑 가장 가까운 집은 left[1000]에 써져 있을 것이다
   이렇게 한번만 구하면 봐야하는 두사람을 굉장히 빠르게 찾을 수 잇다

   그러면 I성향(내향적) 사람이 찾는다고 가정하자
   자신을 기준으로 왼쪽에서 가장 가까운 집과 오른쪽으로 가장 가까운 집을 찾아야하는데

   왼쪽에서 가장 가까운 집은 left[v]에 써 있을 것이다
   오른쪽에서 가장 가까운 집은 right[v]에 써 있을 것이다
   굉장히 빠른 시간에 봐야하는 두 사람을 찾는다 => 상수시간에 알 수 있다


4.구현

   1) 필요한 자료구조 : 정답을 넣을 배열 , 더미배열 , 튜플 형태로 저장
   2) 필요한 알고리즘 : 함수로 left,right 배열 구하기 / while 반복문


5.결론

  - 아이디어 필요 ( 시간복잡도를 해결하기 위해 가장 끝에 있는 사람만 구하면 된다거나 가장 가까운 사람은 자신을 기준으로 왼쪽 오른쪽을 보면됨)
  - 배열을 활용하여 시간복잡도를 줄임 ( 검색기능에서 최적화 필요 =>  인덱스 활용 )

"""

import sys
si = sys.stdin.readline
INF = sys.maxsize
n,m = map(int, input().split()) # 각 동네의 사람 수 입력

a = [] # a동네 (살고 있는 위치, 사람의 번호, 사람의 성향)
b = [] # b동네 (살고 있는 위치, 사람의 번호, 사람의 성향)
fa = [-1 for _ in range(n)] # A동네에 있는 사람이 B동네에 있는 사람을 선택할 경우 정답 기록
fb = [-1 for _ in range(m)] # B동네에 있는 사람이 A동네에 있는 사름을 선택할 경우 정답 기록

for i in range(n):
    v,tp = map(int, si().split())
    a.append([v,i,tp]) # 객체 튜플 형태로 배열에 저장

for i in range(m):
    v,tp = map(int, si().split())
    b.append([v,i,tp])

a.sort() # 살고 있는 집의 위치를 정렬하여 차례대로 가까운집을 선택하도록 한다
b.sort() # 그리고 살고 있는 위치가 같은 경우 가장 낮은 번호의 사람을 찾으려면 그다음 순서 비교를 한다

ans = 0

def calc(x,n):

    left = [-1 for _ in range(1001)] # left[v] := v이하에서 제일 가까운 값을 갖는 친구의 인덱스
    right = [-1 for _ in range(1001)] # right[v] := v이상에서 제일 가까운 값을 갖는 친구의 인덱스
    for i in range(n): # a동네에 살고 있는 사람 각각에 대해서 b동네사람들의 left , right 배열을 구한다
        v = x[i][0]
        if left[v] == -1:
            left[v] = i
            right[v] = i
    for i in range(2,1001):
        if left[i] == -1:
            left[i] = left[i-1]
    for j in range(999,0,-1):
        if right[j] == -1:
            right[j] = right[j+1]

    return left,right

while n > 0 and m > 0: # 기본적으로 1명이 남는순간까지 반복한다 매라운드별 매칭을
    # 1라운드 매칭마다 이 모든 과정이 일어난다
    # A동네에서 상대를 결정하자
    lB,rB = calc(b,m) # lB,rB 동네에 대한 left, right 배열을 구합니다.
    for i in  range(n):
        v = a[i][0] # 이 사람은 v위치에 살고 있다.
        if a[i][2] == -1: # 외향적 사람인 사람이 고려해야할 사항
            left,right = (INF,0) , (INF,0)
            # 왼쪽 오른쪽에 저장하는 정보는 (거리,id) 순으로 하면 알아서 순서대로 비교한다
            # 1이랑 가장 가까운 상대와의 거리
            left = (abs(v-b[rB[1]][0]),-b[rB[1]][1]) # 첫번째 항목은 거리, 두번째는 그 사람의 아이디 (거리가 같다면 더 작은순으로 비교하기 위해 )
            # 1000이랑 가장 가까운 상대와의 거리
            right = (abs(v-b[lB[1000]][0]), -b[lB[1000]][1])
            if left >= right: # 왼쪽에 사는 사람이 더 멀다면 그 사람을 선택
                fa[i] = rB[1]
            else:             # 오른쪽에 사는 사람이 더 멀다면 그 사람을 선택
                fa[i] = lB[1000]
        else: # 내향적인 사람이 고려해야할 사항(추가적으로 고려해야할 사항은 왼쪽 혹은 오른쪽 양쪽에 아무도 없을 수 있다)
            # v위치에서 왼쪽방향으로 가장 가까운 사람 구하기 & 왼쪽으로 사람이 있는경우에만
            left,right = (INF,0),(INF,0) # 초기화
            if lB[v] != -1:
                left = (abs(v-b[lB[v]][0]), b[lB[v]][1])
            # v위치에서 오른쪽방향으로 가장 가까운 사람 구하기
            if rB[v] != -1:
                right = (abs(v-b[rB[v]][0]), b[rB[v]][1])

            if left <= right: # 왼쪽이 더 가깝다면
                fa[i] = lB[v]
            else:             # 오른쪽이 더 가깝다면
                fa[i] = rB[v]

    # B동네에서 A동네를 선택하자
    lA,rA = calc(a,n)
    for j in range(m):
        # 현재 위치 구하기
        v = b[j][0]
        # 외향적인 사람의 경우
        if b[j][2] == -1:
            # 1이랑 가장 가까운 사람을 선택
            left = (abs(v-rA[1][0]), -a[rA[1]][1])
            # 1000이랑 가장 가까운 사람을 선택
            right = (abs(v-lA[1000][0]), -a[rA[1000]][1])
            if left >= right: # 왼쪽이 더 멀다면 혹은 같아서 왼쪽이 번호가 더 낮다면
                fb[j] = rA[1] # 1번 위치에서 가장 가까운 사람을 선택한다
            else:             # 오른쪽이 더 멀다면
                fb[j] = lA[1000] # 1000번 위치에서 가장 가까운 사람을 선택한다

        # 내향적인 사람의 경우
        else:
            # v위치에서 왼쪽으로 가장 가까운 사람을 선택( 왼쪽에 사람이 없는 경우 제외 )
            if lA[v] != -1:
                left = (abs(v-a[lA[v]][0]), a[lA[v]][1])
            # v위치에서 오른쪽으로 가장 가까운 사람을 선택 ( 오른쪽에 사람이 없는 경우 제외 )
            if rA[v] != -1:
                right = (abs(v-a[rA[v]][0]), a[rA[v]][1])
            if left <= right:
                fb[j] = lA[v]
            else:
                fb[j] = rA[v]

    # 여기까지 A동네 각 사람이 B동네 각 사람을 선택하였고 B동네 각 사람이 A동네 각 사람을 선택 완료 하였다
    # fa[i] := A동네 사람 중 i번 번호를 가진 사람이 선택한 B동네 사람의 위치
    # fb[fa[i]] := A동네 사람중 i번인 사람이 선택한 상대(B동네사람)가 선택한 상대의 위치
    # 이제 매칭 되었는가를 확인한다. 확인할 때 A동네에서 선택한 B동네 사람이 다시 그 사람을 선택했는지 확인하면 된다
    falg = False
    # A동네 각 사람의 번호를 모두 순회한다
    for i in range(n):
        # 선택하였을 경우에만 확인한다
        # A동네에서 선택한 B동네 사람이 A동네 사람을 선택 즉, 서로 선택하였을 경우
        if i == fb[fa[i]]:
            a[i][1] = -1 # A동네 사람이 마을에서 나갓다라는 표시로 -1 표기 해준다
            b[fa[i]][1] = -1 # B동네 사람이 마을에서 나갔다는 표시로 -1 표기 해준다
            ans += 1 # 정답 카운팅
            flag = True # 매칭이 선사되었음을 알려줌

    if not flag: # 매칭이 선사되지 않으면 더이상 진행하지 않음
        break
    # 매칭된 사람 제외하고 재셋팅
    a = [v for v in a if v[1] != -1]
    b = [v for v in b if v[1] != -1]
    n = len(a)
    m = len(b)

print(ans)