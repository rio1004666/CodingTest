"""
N개의 수열이 주어진다
3개의 수를 선택해야한다

4,7,5 라면 숫자가 커지지 않는다
이런 경우는 제외한다
4,5,9를 선택한다
오름차순으로 정렬되어있으므로 맞다
n개의 숫자 중 3개의 숫자를 선택했을때
하나라도 있는가 없는가를 대답하면 된다
하나라도 있으면 yes 없으면 no
N 제한은 30만 까지 가능
숫자법위는 int 범위로
n이 크다
우선 완저남색으로 하면 시간초과
30만개중 3개를 고르는 방법의 수  N^3
관찰하기
어떤때에 대답이 False 일까?
어떤 세개를 골라도 증가하지 않음을 의미한다(가정)
어떤때에 대답이 True 인가?
O(N)의 문제를 풀기 위해서
3개가 증가하려면 두번째원소가 첫뻔재원소보다 오른쪽에 있어야 한다
세번째원소가 두번째원소보다 오른쪽에 있어야한다

세개의 숫자중에 두번째원소의 조건은
왼쪽에 나보다 작은애가 있어?
다른 조건은 오른족에 나보다 큰애가 잇어?
이 두조건 모두다 yeS여야 한다

4 7 5 3 9는
4는 왼족에 작은애가 없다
7은 왼쪽에 작은애가 4가 있고
5는 왼쪽에 작은애가 4가 있다
3은 왼쪽에 작은애가 없다
9도 온쪽에 작은애가 있다

오른쪽부터 살펴보면
9는 오른쪽에 큰애가 없다
3은 오른쪽에 큰애가 있다
5는 오른쪽에 큰애가 있다
7도 오른쪽에 큰애가 있다
4도 오른쪽에 큰액가 있다

이러한 조건으로 7이 가운데로 올 수 있는 친구이다
5도 가운데로 올 수 있는 친구이다

왼쪽에 작은애가 있는지 오른쪽에 큰애가 있는지 확인만하면 되는구나!
둘다 만족하면 yes로 하면 된다
l배열과 r배열을 구할것이다
왼쪽부터 차례대로 가면서
x왼쪽에 x보다 작은것이 있나?
그냥 대답하려면 왼쪽을 전부 탐색해야할것같지만
다르게 질문을 해보면 x보다 왼쪽에서 제일 작은수가
x보다 작아? 라는 질문이랑 같다
제일 작은수보다는 다 클것이기때문에 제일 작은수보다
크기만하면 된다
반대로 오른족도 제일 큰수를 구하면
나머지는 제일 큰수보다 작기때문에
오른쪽에 있는 수가 최댓값을 기억하고 잇으면
그것보다 작으면 yes라고 대답할 수 잇따

이러면 O(N)에 계산이 가능하다

위의 예에서 4 7 5 3 9는
7에서 왼쪽에서 최솟값은 4이고
5에 왓을때 최솟값도 여전히 4이고 그것보다 크다
3은 최솟값인 4보다 작기때문에 no이다

NlogN 도 가능하다
LIS >= 3
이분탐색도 가능하고
하지만 고인물지식이 없어도 출분히 코테레벨에서는 가능하다

3개를 선택햇다는 점을 찾안하면 충분히 이렇게 푸는것이 가능하다

"""
import sys
si = sys.stdin.readline
n = int(si())
a = list(map(int, si().split()))
L = [False for _ in range(n)]
R = [False for _ in range(n)]
min_v = a[0]  # 왼쪽에 존재하는 최솟값
for i in range(1, n):
    if a[i] > min_v:
        L[i] = True
    min_v = min(min_v, a[i])
max_v = a[n - 1]
for i in range(n - 2, -1, -1):
    if a[i] < max_v:
        R[i] = True
    max_v = max(max_v, a[i])
for i in range(n):
    if L[i] and R[i]:
        print("TRUE")
        exit()
print("FALSE")